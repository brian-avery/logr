/*
Copyright 2021 The logr Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package funcr implements github.com/go-logr/logr.Logger in terms of
// an arbitrary "write" function.
package funcr

import (
	"bytes"
	"encoding/json"
	"fmt"
	"path/filepath"
	"runtime"

	"github.com/go-logr/logr"
)

// New returns a logr.Logger which is implemented by a function.
func New(fn func(args ...string)) logr.Logger {
	return fnlogger{
		level:  0,
		prefix: "",
		values: nil,
		write:  fn,
	}
}

type fnlogger struct {
	level  int
	prefix string
	values []interface{}
	write  func(args ...string)
}

// Magic string for intermediate frames that we should ignore.
const autogeneratedFrameName = "<autogenerated>"

// Discover how many frames we need to climb to find the caller. This approach
// was suggested by Ian Lance Taylor of the Go team, so it *should* be safe
// enough (famous last words).
func framesToCaller() int {
	// 1 is the immediate caller.  3 should be too many.
	for i := 1; i < 3; i++ {
		_, file, _, _ := runtime.Caller(i + 1) // +1 for this function's frame
		if file != autogeneratedFrameName {
			return i
		}
	}
	return 1 // something went wrong, this is safe
}

func flatten(kvList ...interface{}) string {
	if len(kvList)%2 != 0 {
		kvList = append(kvList, "<no-value>")
	}
	// Empirically bytes.Buffer is faster than strings.Builder for this.
	buf := bytes.NewBuffer(make([]byte, 0, 1024))
	for i := 0; i < len(kvList); i += 2 {
		k, ok := kvList[i].(string)
		if !ok {
			k = fmt.Sprintf("<non-string-key-%d>", i/2)
		}
		v := kvList[i+1]

		if i > 0 {
			buf.WriteRune(' ')
		}
		buf.WriteRune('"')
		buf.WriteString(k)
		buf.WriteRune('"')
		buf.WriteRune('=')
		buf.WriteString(pretty(v))
	}
	return buf.String()
}

func pretty(value interface{}) string {
	// TODO: This is not fast. Most of the overhead goes here.
	jb, _ := json.Marshal(value)
	return string(jb)
}

type callerID struct {
	File string `json:"file"`
	Line int    `json:"line"`
}

func (l fnlogger) caller() callerID {
	_, file, line, ok := runtime.Caller(framesToCaller() + 1) // +1 for this frame
	if !ok {
		return callerID{"<unknown>", 0}
	}
	return callerID{filepath.Base(file), line}
}

func (l fnlogger) Enabled() bool {
	return l.level == 0
}

func (l fnlogger) Info(msg string, kvList ...interface{}) {
	if l.Enabled() {
		builtin := make([]interface{}, 0, 8)
		builtin = append(builtin, "caller", l.caller())
		builtin = append(builtin, "level", l.level, "msg", msg)
		builtinStr := flatten(builtin...)
		fixedStr := flatten(l.values...)
		userStr := flatten(kvList...)
		l.write(l.prefix, " ", builtinStr, " ", fixedStr, " ", userStr)
	}
}

func (l fnlogger) Error(err error, msg string, kvList ...interface{}) {
	builtin := make([]interface{}, 0, 4)
	builtin = append(builtin, "caller", l.caller())
	builtin = append(builtin, "msg", msg)
	builtinStr := flatten(builtin...)
	var loggableErr interface{}
	if err != nil {
		loggableErr = err.Error()
	}
	errStr := flatten("error", loggableErr)
	fixedStr := flatten(l.values...)
	userStr := flatten(kvList...)
	l.write(l.prefix, " ", builtinStr, " ", errStr, " ", fixedStr, " ", userStr)
}

func (l fnlogger) V(level int) logr.Logger {
	l.level += level
	return l
}

// WithName returns a new Logger with the specified name appended.  funcr
// uses '/' characters to separate name elements.  Callers should not pass '/'
// in the provided name string, but this library does not actually enforce that.
func (l fnlogger) WithName(name string) logr.Logger {
	if len(l.prefix) > 0 {
		l.prefix = l.prefix + "/"
	}
	l.prefix += name
	return l
}

func (l fnlogger) WithValues(kvList ...interface{}) logr.Logger {
	// Three slice args forces a copy.
	n := len(l.values)
	l.values = append(l.values[:n:n], kvList...)
	return l
}

var _ logr.Logger = fnlogger{}
